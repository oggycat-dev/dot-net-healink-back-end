# UserId vs UserProfileId Pattern

## üéØ Overview

Ph√¢n bi·ªát r√µ r√†ng gi·ªØa **UserId (Authentication)** v√† **UserProfileId (Business Logic)** ƒë·ªÉ ƒë·∫£m b·∫£o security v√† data integrity.

**Critical Rule**: UserId from JWT token is for AUTHENTICATION only. UserProfileId from Redis cache is for BUSINESS LOGIC.

---

## üîë Key Concepts

### 1. **UserId (Authentication)**

**Source**: JWT Token  
**Purpose**: Authentication & Authorization only  
**Managed by**: AuthService  
**Stored in**: JWT Claims

**Properties**:
- ‚úÖ Used for verifying user identity
- ‚úÖ Used for Gateway authentication
- ‚ùå **NEVER** use directly in business logic
- ‚ùå **NEVER** store in database as foreign key

**Example**:
```csharp
var authUserId = _currentUserService.UserId; // From JWT token
// ‚úÖ Use for: Authentication check
// ‚ùå DON'T use for: Creating subscriptions, orders, etc.
```

---

### 2. **UserProfileId (Business Logic)**

**Source**: Redis Cache (UserStateCache)  
**Purpose**: Business operations & database relations  
**Managed by**: UserService  
**Stored in**: Redis + Database

**Properties**:
- ‚úÖ Used for all business logic operations
- ‚úÖ Used as foreign key in database
- ‚úÖ Retrieved from cache using UserId
- ‚úÖ Represents actual user profile in UserService

**Example**:
```csharp
var userState = await _userStateCache.GetUserStateAsync(authUserId);
var userProfileId = userState.UserId; // This is UserProfileId
// ‚úÖ Use for: Creating subscriptions, orders, transactions
// ‚úÖ Use for: Database foreign keys
```

---

## üèóÔ∏è Architecture Flow

```
1. User Login
   ‚Üì
2. AuthService generates JWT Token
   - Contains: UserId (for auth)
   ‚Üì
3. UserService caches user state in Redis
   - Contains: UserId (UserProfileId), Email, Roles, Status
   ‚Üì
4. User Request ‚Üí Gateway
   - Gateway validates JWT token (uses UserId for auth)
   - Gateway queries Redis cache
   - Gateway sets user claims from cache
   ‚Üì
5. Service receives request
   - Get UserId from JWT (authentication)
   - Query UserProfileId from Redis cache
   - Use UserProfileId for business logic
```

---

## üìä Implementation Pattern

### Step 1: Inject Dependencies

```csharp
public class RegisterSubscriptionCommandHandler 
{
    private readonly ICurrentUserService _currentUserService;
    private readonly IUserStateCache _userStateCache;
    
    public RegisterSubscriptionCommandHandler(
        ICurrentUserService currentUserService,
        IUserStateCache userStateCache)
    {
        _currentUserService = currentUserService;
        _userStateCache = userStateCache;
    }
}
```

---

### Step 2: Get UserId (Authentication)

```csharp
// ‚úÖ Step 1: Get UserId from JWT token (for AUTHENTICATION only)
var userIdStr = _currentUserService.UserId;
if (string.IsNullOrEmpty(userIdStr) || !Guid.TryParse(userIdStr, out var authUserId))
{
    return Result.Failure("User not authenticated", ErrorCodeEnum.Unauthorized);
}
```

---

### Step 3: Get UserProfileId from Cache

```csharp
// ‚úÖ Step 2: Get UserProfileId from Redis cache (for BUSINESS LOGIC)
var userState = await _userStateCache.GetUserStateAsync(authUserId);
if (userState == null)
{
    _logger.LogWarning("User state not found in cache for UserId={UserId}", authUserId);
    return Result.Failure("User session not found. Please login again.", ErrorCodeEnum.Unauthorized);
}

if (!userState.IsActive)
{
    _logger.LogWarning("User {UserId} is inactive. Status={Status}", authUserId, userState.Status);
    return Result.Failure("User account is inactive", ErrorCodeEnum.Forbidden);
}

// ‚úÖ UserProfileId from cache - THIS is used for business logic
var userProfileId = userState.UserId; // This is the actual UserProfileId from UserService
```

---

### Step 4: Use UserProfileId for Business Logic

```csharp
// ‚úÖ Create entity with UserProfileId
var subscription = new Subscription
{
    UserProfileId = userProfileId, // ‚úÖ Business logic uses UserProfileId
    SubscriptionPlanId = planId,
    SubscriptionStatus = SubscriptionStatus.Pending
};
subscription.InitializeEntity(userProfileId); // ‚úÖ CreatedBy = UserProfileId

// ‚úÖ Query existing data
var existingSubscription = await _repository.GetFirstOrDefaultAsync(
    s => s.UserProfileId == userProfileId && // ‚úÖ Use UserProfileId
         s.SubscriptionStatus == SubscriptionStatus.Active);

// ‚úÖ Send events
var sagaEvent = new SubscriptionRegistrationStarted
{
    UserProfileId = userProfileId, // ‚úÖ Use UserProfileId
    CreatedBy = userProfileId // ‚úÖ Use UserProfileId
};
```

---

## ‚úÖ Example: RegisterSubscriptionCommandHandler

### Complete Implementation

```csharp
public async Task<Result<object>> Handle(RegisterSubscriptionCommand command, CancellationToken cancellationToken)
{
    try
    {
        // ‚úÖ Step 1: Get UserId from JWT token (for AUTHENTICATION only)
        var userIdStr = _currentUserService.UserId;
        if (string.IsNullOrEmpty(userIdStr) || !Guid.TryParse(userIdStr, out var authUserId))
        {
            return Result<object>.Failure("User not authenticated", ErrorCodeEnum.Unauthorized);
        }

        // ‚úÖ Step 2: Get UserProfileId from Redis cache (for BUSINESS LOGIC)
        var userState = await _userStateCache.GetUserStateAsync(authUserId);
        if (userState == null)
        {
            _logger.LogWarning("User state not found in cache for UserId={UserId}", authUserId);
            return Result<object>.Failure("User session not found. Please login again.", ErrorCodeEnum.Unauthorized);
        }

        if (!userState.IsActive)
        {
            _logger.LogWarning("User {UserId} is inactive. Status={Status}", authUserId, userState.Status);
            return Result<object>.Failure("User account is inactive", ErrorCodeEnum.Forbidden);
        }

        // ‚úÖ UserProfileId from cache - THIS is used for business logic
        var userProfileId = userState.UserId;

        _logger.LogInformation(
            "Processing subscription registration: AuthUserId={AuthUserId}, UserProfileId={UserProfileId}",
            authUserId, userProfileId);

        // ‚úÖ Step 3: Use UserProfileId for all business operations
        
        // Validate plan
        var plan = await _repository.GetFirstOrDefaultAsync(
            p => p.Id == command.Request.SubscriptionPlanId);
        
        // Check existing subscription (use UserProfileId)
        var existingSubscription = await _repository.GetFirstOrDefaultAsync(
            s => s.UserProfileId == userProfileId && 
                 s.SubscriptionStatus == SubscriptionStatus.Active);
        
        if (existingSubscription != null)
        {
            return Result<object>.Failure("Already has active subscription", ErrorCodeEnum.DuplicateEntry);
        }

        // Create subscription (use UserProfileId)
        var subscription = new Subscription
        {
            UserProfileId = userProfileId, // ‚úÖ Business logic uses UserProfileId
            SubscriptionPlanId = plan.Id,
            SubscriptionStatus = SubscriptionStatus.Pending
        };
        subscription.InitializeEntity(userProfileId); // ‚úÖ CreatedBy = UserProfileId

        await _repository.AddAsync(subscription);
        await _unitOfWork.SaveChangesAsync();

        // Publish event (use UserProfileId)
        var sagaEvent = new SubscriptionRegistrationStarted
        {
            SubscriptionId = subscription.Id,
            UserProfileId = userProfileId, // ‚úÖ Use UserProfileId
            CreatedBy = userProfileId // ‚úÖ Use UserProfileId
        };
        await _publishEndpoint.Publish(sagaEvent, cancellationToken);

        return Result<object>.Success(new { SubscriptionId = subscription.Id });
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error registering subscription");
        return Result<object>.Failure("Error registering subscription", ErrorCodeEnum.InternalError);
    }
}
```

---

## üö´ Common Mistakes

### ‚ùå WRONG: Using UserId directly for business logic

```csharp
// ‚ùå BAD - Using JWT UserId for business logic
var userId = _currentUserService.UserId;

var subscription = new Subscription
{
    UserProfileId = userId, // ‚ùå WRONG - This is auth UserId, not UserProfileId
};

var existingSubscription = await _repository.GetFirstOrDefaultAsync(
    s => s.UserProfileId == userId); // ‚ùå WRONG - Won't find correct user's data
```

**Problem**: 
- UserId from JWT might not match UserProfileId in database
- Can cause data integrity issues
- Can expose other users' data

---

### ‚úÖ CORRECT: Query UserProfileId from cache

```csharp
// ‚úÖ GOOD - Get UserProfileId from cache
var authUserId = _currentUserService.UserId; // For authentication
var userState = await _userStateCache.GetUserStateAsync(authUserId);
var userProfileId = userState.UserId; // For business logic

var subscription = new Subscription
{
    UserProfileId = userProfileId, // ‚úÖ CORRECT
};

var existingSubscription = await _repository.GetFirstOrDefaultAsync(
    s => s.UserProfileId == userProfileId); // ‚úÖ CORRECT
```

---

## üîê Security Benefits

### 1. **Separation of Concerns**
- Authentication logic separate from business logic
- Clear boundaries between services

### 2. **Data Integrity**
- Always use correct UserProfileId from UserService
- Prevent data leakage between users

### 3. **Cache Validation**
- Verify user is active before processing
- Check user state from Redis

### 4. **Audit Trail**
- Clear tracking: AuthUserId ‚Üí UserProfileId
- Easy to debug issues

---

## üìö Related Services

### AuthService
- **Responsibility**: User authentication & JWT token generation
- **Manages**: UserId (for authentication)
- **Database**: AppUser table

### UserService
- **Responsibility**: User profile management
- **Manages**: UserProfileId, Email, Roles, Status
- **Database**: UserProfile table
- **Cache**: Redis (UserStateCache)

### Other Services
- **Responsibility**: Business logic (subscriptions, payments, etc.)
- **Uses**: UserProfileId from cache
- **Never**: Use UserId directly for business logic

---

## üß™ Testing

### Test User Authentication

```csharp
[Fact]
public async Task Handle_ValidUser_ReturnsUserProfileId()
{
    // Arrange
    var authUserId = Guid.NewGuid(); // From JWT
    var userProfileId = Guid.NewGuid(); // From UserService
    
    _currentUserService.UserId.Returns(authUserId.ToString());
    _userStateCache.GetUserStateAsync(authUserId).Returns(new UserStateInfo
    {
        UserId = userProfileId, // This is UserProfileId
        IsActive = true
    });
    
    // Act
    var result = await _handler.Handle(command, CancellationToken.None);
    
    // Assert
    // Verify UserProfileId was used, not authUserId
    _repository.Received(1).AddAsync(Arg.Is<Subscription>(
        s => s.UserProfileId == userProfileId)); // ‚úÖ Should use UserProfileId
}
```

---

## ‚ö†Ô∏è Important Notes

### 1. **Always Query Cache First**
```csharp
// ‚úÖ DO THIS
var userState = await _userStateCache.GetUserStateAsync(authUserId);
var userProfileId = userState.UserId;

// ‚ùå DON'T DO THIS
var userProfileId = _currentUserService.UserId; // This is auth UserId!
```

### 2. **Handle Cache Miss**
```csharp
if (userState == null)
{
    // User session expired or invalid
    return Result.Failure("User session not found. Please login again.", ErrorCodeEnum.Unauthorized);
}
```

### 3. **Verify User Status**
```csharp
if (!userState.IsActive)
{
    return Result.Failure("User account is inactive", ErrorCodeEnum.Forbidden);
}
```

### 4. **Log Both IDs for Debugging**
```csharp
_logger.LogInformation(
    "Processing request: AuthUserId={AuthUserId}, UserProfileId={UserProfileId}",
    authUserId, userProfileId);
```

---

## üìä Data Flow Diagram

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. User Login                                               ‚îÇ
‚îÇ    POST /api/user/auth/login                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. AuthService                                              ‚îÇ
‚îÇ    - Validates credentials                                  ‚îÇ
‚îÇ    - Generates JWT with UserId (auth ID)                    ‚îÇ
‚îÇ    - Returns JWT token                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. UserService                                              ‚îÇ
‚îÇ    - Caches user state in Redis                             ‚îÇ
‚îÇ    - Key: AuthUserId                                        ‚îÇ
‚îÇ    - Value: { UserId (UserProfileId), Email, Roles, ... }   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 4. User Request (with JWT token)                            ‚îÇ
‚îÇ    POST /api/user/subscriptions/register                    ‚îÇ
‚îÇ    Authorization: Bearer <JWT with UserId>                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 5. Gateway                                                  ‚îÇ
‚îÇ    - Validates JWT (extracts UserId)                        ‚îÇ
‚îÇ    - Queries Redis cache (UserId ‚Üí UserProfileId)           ‚îÇ
‚îÇ    - Sets user claims from cache                            ‚îÇ
‚îÇ    - Forwards to SubscriptionService                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 6. SubscriptionService Handler                              ‚îÇ
‚îÇ    Step 1: Get UserId from JWT (authentication)             ‚îÇ
‚îÇ            var authUserId = _currentUserService.UserId;     ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ    Step 2: Query UserProfileId from Redis                   ‚îÇ
‚îÇ            var userState = await _cache.Get(authUserId);    ‚îÇ
‚îÇ            var userProfileId = userState.UserId;            ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ    Step 3: Use UserProfileId for business logic             ‚îÇ
‚îÇ            subscription.UserProfileId = userProfileId;      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## ‚úÖ Checklist for Handlers

When implementing any command/query handler:

- [ ] ‚úÖ Inject `ICurrentUserService` for authentication
- [ ] ‚úÖ Inject `IUserStateCache` for UserProfileId
- [ ] ‚úÖ Get `UserId` from JWT token first
- [ ] ‚úÖ Query `UserStateCache` with UserId
- [ ] ‚úÖ Extract `UserProfileId` from cache
- [ ] ‚úÖ Validate user is active (`userState.IsActive`)
- [ ] ‚úÖ Use `UserProfileId` for all business logic
- [ ] ‚úÖ Use `UserProfileId` for database operations
- [ ] ‚úÖ Use `UserProfileId` in events
- [ ] ‚úÖ Log both IDs for debugging
- [ ] ‚ùå **NEVER** use JWT UserId directly for business logic

---

## üéØ Summary

| Aspect | UserId (JWT) | UserProfileId (Cache) |
|--------|--------------|----------------------|
| **Source** | JWT Token | Redis Cache |
| **Purpose** | Authentication | Business Logic |
| **Service** | AuthService | UserService |
| **Usage** | Verify identity | Database operations |
| **In Code** | `_currentUserService.UserId` | `userState.UserId` |
| **For Business** | ‚ùå No | ‚úÖ Yes |
| **Foreign Key** | ‚ùå No | ‚úÖ Yes |

**Golden Rule**: UserId for Auth, UserProfileId for Business! üéØ

---

**Status**: ‚úÖ Pattern Documented  
**Applies to**: All services (Subscription, Payment, Order, etc.)  
**Last Updated**: 2025-10-12

